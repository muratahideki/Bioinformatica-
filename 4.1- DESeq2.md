## Ler o arquivo em R

```R
# Lê o arquivo, ignorando linhas que começam com #
counts <- read.table("counts.txt", header = TRUE, row.names = 1, comment.char = "#")

# Mostra as primeiras linhas
head(counts)
```

- `header = TRUE` → a primeira linha tem os nomes das amostras.
- `row.names = 1` → a primeira coluna (GeneID) será usada como nome das linhas.
- `comment.char` = "#" → ignora linhas de comentários do featureCounts.

## DESeq2

### Leitura 
- O DESeq2 só precisa da coluna Geneid e das colunas de contagem.
- A primeira coluna é Geneid
- As colunas de 2 a 6 (Chr, Start, End, Strand, Length) são metadados
- A 7ª coluna é de contagem por amostra (no seu caso, apenas arquivo_sorted.bam).

```R
counts <- counts_raw[, c(1, 7:ncol(counts_raw))]

# Tornar Geneid o nome das linhas
rownames(counts) <- counts$Geneid
counts <- counts[, -1]
```
- `rownames(counts) <- counts$Geneid` : Use os valores da coluna Geneid como nomes das linhas da tabela counts.
- `counts <- counts[, -1]`: Remova a primeira coluna da tabela counts.

### Criar Dataframe 

```R
coldata <- data.frame(
  row.names = colnames(counts),
  condition = c("control")  # altere conforme o número de amostras
)
```

1) `colnames(counts)`<br>
Essa função pega os nomes das colunas da sua matriz de contagens, ou seja, os nomes das amostras (que vêm dos arquivos BAM no featureCounts).

- No meu caso: 
```R
colnames(counts)
# [1] "arquivo_sorted.bam"
```

- Com várias amostras
```R
colnames(counts)
# [1] "ctrl1.bam" "ctrl2.bam" "treat1.bam"
```

2) `row.names = colnames(counts)`

Assim eu pego o nome das colunas e transformo em nomes das linhas. Essa é a condição para usar `DESeq2`

3) `condition = c("control")`

Essa linha define que amostra é de controle. Isso é feito porque temos somente uma amostra. Se tivessemos mais poderia ser também "treatment"

```R
coldata <- data.frame(
  row.names = colnames(counts),
  condition = c("control", "control", "treatment", "treatment")
)
```

### Criar o objeto DESeq2

```R
dds <- DESeqDataSetFromMatrix(
  countData = counts,
  colData = coldata,
  design = ~ condition
)
```

Ela cria um objeto DESeqDataSet, que é a estrutura central que o DESeq2 usa para realizar toda a análise de expressão diferencial.

Esse objeto combina:
1) Os dados de contagem (quantos reads caíram em cada gene por amostra)<br>
2) Os metadados das amostras (por exemplo, grupo controle x tratado)<br>
3) O modelo experimental (design).

`countData = counts`

É a matriz de contagens — normalmente vem do arquivo do featureCounts.Os valores são contagens brutas de reads.

| gene  | sample1 | sample2 | sample3 |
| ----- | ------- | ------- | ------- |
| GeneA | 120     | 200     | 180     |
| GeneB | 5       | 3       | 10      |


`colData = coldata`

É um data frame com informações sobre cada amostra, que deve ter as mesmas colunas (nomes) da matriz de contagem.

| sample  | condition |
| ------- | --------- |
| sample1 | control   |
| sample2 | treated   |
| sample3 | treated   |


- `design = ~ condition`

É o modelo estatístico — ele diz o que você quer comparar.<br>
condition: significa “modelar as contagens em função da condição experimental”.

- Como eu tenho uma única amostra vai comparar com o que ?

Se você só tem uma amostra, não há variação biológica entre réplicas para estimar a dispersão — o que significa que o DESeq2 não tem base estatística para calcular p-values ou fold changes confiáveis.

Mesmo assim, dá pra usar parte do pipeline pra obter informações úteis:
1) Normalizar as contagens (para comparar entre genes da mesma amostra);
2) Gerar TPM, FPKM ou CPM (expressão relativa dentro da amostra);
3) Explorar os genes mais expressos;
4) Comparar com dados públicos depois.

### Terminando

```R

# Filtrar genes com baixa contagem
dds <- dds[rowSums(counts(dds)) >= 10, ]

# Rodar o DESeq2
dds <- DESeq(dds)

# Extrair resultados
res <- results(dds)

# Salvar resultados
write.csv(as.data.frame(res), file = "DESeq2_results.csv")
```







